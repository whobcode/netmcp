// ExploitDB Toolkit for MCP Server
// Provides exploit database search and lookup functionality

import { z } from "zod";
import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

// Types
interface ExploitEntry {
  id: number;
  title: string;
  file: string;
  kind: string;
  platform?: string;
  type?: string;
  verified: boolean;
  codes?: string[];
  tags?: string[];
  aliases?: string[];
  port?: number;
  date_published?: string;
  date_added?: string;
  date_updated?: string;
  screenshot_url?: string;
  application_url?: string;
  source_url?: string;
  preview?: string;
}

interface NormalizedEntry extends ExploitEntry {
  searchText: string;
  normalizedTitle: string;
  cves: string[];
  slug: string;
}

interface DatasetMeta {
  generated_at: string;
  entry_count: number;
  total_available: number;
  limit: number;
}

interface Dataset {
  generated_at: string;
  entry_count: number;
  total_available: number;
  limit: number;
  entries: ExploitEntry[];
}

// Dataset cache
let datasetCache: Dataset | null = null;
let normalizedEntriesCache: NormalizedEntry[] | null = null;

// Base64 decode and gunzip for Workers environment
async function decodeAndDecompress(base64Data: string): Promise<string> {
  // Decode base64 to binary
  const binaryString = atob(base64Data);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }

  // Decompress using DecompressionStream (available in Workers)
  const ds = new DecompressionStream("gzip");
  const writer = ds.writable.getWriter();
  writer.write(bytes);
  writer.close();

  const reader = ds.readable.getReader();
  const chunks: Uint8Array[] = [];

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
  }

  // Combine chunks
  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }

  // Decode UTF-8
  return new TextDecoder().decode(result);
}

// Load dataset from base64 compressed data
export async function loadDataset(base64CompressedData: string): Promise<Dataset> {
  if (datasetCache) return datasetCache;

  try {
    const jsonString = await decodeAndDecompress(base64CompressedData);
    datasetCache = JSON.parse(jsonString);
    return datasetCache!;
  } catch (error: any) {
    console.error("Failed to load ExploitDB dataset:", error);
    throw new Error(`Failed to load dataset: ${error.message}`);
  }
}

// Set dataset directly (for pre-loaded data)
export function setDataset(dataset: Dataset) {
  datasetCache = dataset;
  normalizedEntriesCache = null;
}

function getDataset(): Dataset {
  if (!datasetCache) {
    throw new Error("ExploitDB dataset not loaded. Call loadDataset() first.");
  }
  return datasetCache;
}

function buildSlug(entry: ExploitEntry): string {
  const prefix = entry.kind === "shellcode" ? "shellcode" : "exploit";
  const safeTitle = (entry.title || "")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .slice(0, 64);
  return `${prefix}-${entry.id || "unknown"}${safeTitle ? `-${safeTitle}` : ""}`;
}

function getNormalizedEntries(): NormalizedEntry[] {
  if (!normalizedEntriesCache) {
    const dataset = getDataset();
    normalizedEntriesCache = dataset.entries.map((entry) => {
      const cves = (entry.codes || []).filter((code) => code?.startsWith?.("CVE-"));
      const normalizedTitle = (entry.title || "").trim();
      const searchText = [
        normalizedTitle,
        entry.file || "",
        entry.platform || "",
        entry.type || "",
        ...(entry.codes || []),
        ...(entry.tags || []),
        ...(entry.aliases || []),
        entry.preview || "",
      ]
        .join(" ")
        .toLowerCase();
      return {
        ...entry,
        searchText,
        normalizedTitle,
        cves,
        slug: buildSlug(entry),
      };
    });
  }
  return normalizedEntriesCache;
}

function tokenize(query = ""): string[] {
  return query
    .toLowerCase()
    .split(/\s+/)
    .map((token) => token.trim())
    .filter(Boolean);
}

function scoreEntry(entry: NormalizedEntry, tokens: string[]): number {
  if (!tokens.length) return 0;
  let score = 0;
  for (const token of tokens) {
    if (!token) continue;
    if (entry.searchText.includes(token)) {
      score += 4;
    }
    if (entry.cves.some((cve) => cve.toLowerCase() === token)) {
      score += 6;
    }
    if (String(entry.id) === token) {
      score += 8;
    }
    if (entry.platform && entry.platform.toLowerCase() === token) {
      score += 2;
    }
    if (entry.type && entry.type.toLowerCase() === token) {
      score += 2;
    }
  }
  return score;
}

export function datasetMeta(): DatasetMeta {
  const { generated_at, entry_count, total_available, limit } = getDataset();
  return { generated_at, entry_count, total_available, limit };
}

interface SearchParams {
  query?: string;
  limit?: number;
  platform?: string;
  type?: string;
  verified?: boolean;
  kind?: string;
}

interface SerializedEntry {
  id: number;
  title: string;
  file: string;
  kind: string;
  platform?: string;
  type?: string;
  verified: boolean;
  cves: string[];
  codes: string[];
  tags: string[];
  aliases: string[];
  port?: number;
  date_published?: string;
  date_added?: string;
  date_updated?: string;
  screenshot_url?: string;
  application_url?: string;
  source_url?: string;
  slug: string;
  score?: number;
  preview_excerpt?: string;
  preview?: string;
}

function serializeEntry(
  entry: NormalizedEntry,
  score: number | null,
  { includePreview = false } = {}
): SerializedEntry {
  const base: SerializedEntry = {
    id: entry.id,
    title: entry.normalizedTitle,
    file: entry.file,
    kind: entry.kind,
    platform: entry.platform,
    type: entry.type,
    verified: entry.verified,
    cves: entry.cves,
    codes: entry.codes || [],
    tags: entry.tags || [],
    aliases: entry.aliases || [],
    port: entry.port,
    date_published: entry.date_published,
    date_added: entry.date_added,
    date_updated: entry.date_updated,
    screenshot_url: entry.screenshot_url,
    application_url: entry.application_url,
    source_url: entry.source_url,
    slug: entry.slug,
  };
  if (typeof score === "number") {
    base.score = score;
  }
  if (entry.preview) {
    base.preview_excerpt = entry.preview.slice(0, 280);
  }
  if (includePreview && entry.preview) {
    base.preview = entry.preview;
  }
  return base;
}

export function searchExploitDataset({
  query = "",
  limit = 10,
  platform,
  type,
  verified,
  kind,
}: SearchParams = {}) {
  const tokens = tokenize(query);
  let candidates = getNormalizedEntries();

  if (platform) {
    const needle = platform.toLowerCase();
    candidates = candidates.filter((entry) => entry.platform?.toLowerCase() === needle);
  }
  if (type) {
    const typeNeedle = type.toLowerCase();
    candidates = candidates.filter((entry) => entry.type?.toLowerCase() === typeNeedle);
  }
  if (typeof verified === "boolean") {
    candidates = candidates.filter((entry) => entry.verified === verified);
  }
  if (kind) {
    const kindNeedle = kind.toLowerCase();
    candidates = candidates.filter((entry) => entry.kind?.toLowerCase() === kindNeedle);
  }

  const scored = candidates
    .map((entry) => ({
      entry,
      score: tokens.length ? scoreEntry(entry, tokens) : 1,
    }))
    .filter(({ score }) => score > 0);

  scored.sort((a, b) => {
    if (b.score !== a.score) {
      return b.score - a.score;
    }
    const dateA = a.entry.date_published || a.entry.date_added || "1970-01-01";
    const dateB = b.entry.date_published || b.entry.date_added || "1970-01-01";
    if (dateA === dateB) {
      return (b.entry.id || 0) - (a.entry.id || 0);
    }
    return dateB.localeCompare(dateA);
  });

  const cappedLimit = Math.max(1, Math.min(limit || 10, getNormalizedEntries().length, 200));
  const sliced = scored.slice(0, cappedLimit);

  return {
    query,
    limit,
    matches: sliced.map(({ entry, score }) => serializeEntry(entry, score)),
    total_matches: scored.length,
    meta: datasetMeta(),
  };
}

export function getExploitById(id: number | string): SerializedEntry | null {
  const needle = Number(id);
  const found = getNormalizedEntries().find((entry) => entry.id === needle);
  if (!found) {
    return null;
  }
  return serializeEntry(found, null, { includePreview: true });
}

export function formatSearchResultsMarkdown(result: ReturnType<typeof searchExploitDataset>): string {
  if (!result.matches.length) {
    return [
      "### ExploitDB Search",
      `Query: \`${result.query || "∅"}\``,
      "",
      "No matches found in the dataset.",
    ].join("\n");
  }
  const lines = [
    "### ExploitDB Search Results",
    `Query: \`${result.query || "∅"}\` · Showing ${result.matches.length} of ${result.total_matches}`,
    `Dataset updated: ${result.meta.generated_at}`,
    "",
  ];
  for (const match of result.matches) {
    const badge = [
      match.kind === "shellcode" ? "shellcode" : "exploit",
      match.platform || "unknown platform",
      match.type || "unknown type",
    ].join(" · ");
    const cveLine = match.cves?.length ? ` · CVEs: ${match.cves.join(", ")}` : "";
    lines.push(
      `- **${match.title}** (ID ${match.id})`,
      `  - ${badge}${cveLine}`,
      `  - Path: \`${match.file}\`${match.score != null ? ` · Score: ${match.score}` : ""}`
    );
  }
  return lines.join("\n");
}

export function formatEntryMarkdown(entry: SerializedEntry | null): string {
  if (!entry) {
    return "No entry found.";
  }
  const lines = [
    `### ${entry.title} (ID ${entry.id})`,
    `Kind: ${entry.kind} · Platform: ${entry.platform || "unknown"} · Type: ${entry.type || "unknown"}`,
    `Verified: ${entry.verified ? "yes" : "no"}${entry.port ? ` · Port: ${entry.port}` : ""}`,
    `File: \`${entry.file}\``,
  ];
  if (entry.cves?.length) {
    lines.push(`CVEs: ${entry.cves.join(", ")}`);
  }
  if (entry.codes?.length) {
    lines.push(`Codes: ${entry.codes.join(", ")}`);
  }
  if (entry.tags?.length) {
    lines.push(`Tags: ${entry.tags.join(", ")}`);
  }
  if (entry.aliases?.length) {
    lines.push(`Aliases: ${entry.aliases.join(", ")}`);
  }
  if (entry.date_published || entry.date_added) {
    lines.push(
      `Dates: published ${entry.date_published || "n/a"}, added ${entry.date_added || "n/a"}, updated ${
        entry.date_updated || "n/a"
      }`
    );
  }
  if (entry.source_url) {
    lines.push(`Source: ${entry.source_url}`);
  }
  if (entry.application_url) {
    lines.push(`Vendor: ${entry.application_url}`);
  }
  if (entry.preview) {
    lines.push("", "```", entry.preview.slice(0, 1200), "```");
  }
  return lines.join("\n");
}

// Check if dataset is loaded
export function isDatasetLoaded(): boolean {
  return datasetCache !== null;
}

// Register ExploitDB tools
export function registerExploitDbTools(server: McpServer) {
  // ExploitDB Search Tool
  server.tool(
    "exploitdb_search",
    "Search the ExploitDB database for exploits by keyword, CVE, platform, or type.",
    {
      query: z.string().optional().describe("Search query (keywords, CVE ID, or exploit name)"),
      platform: z.string().optional().describe("Filter by platform (e.g., linux, windows, multiple)"),
      type: z.string().optional().describe("Filter by exploit type (e.g., local, remote, webapps, dos)"),
      verified: z.boolean().optional().describe("Filter by verification status"),
      kind: z.enum(["exploit", "shellcode"]).optional().describe("Filter by kind (exploit or shellcode)"),
      limit: z.number().int().min(1).max(200).optional().default(10).describe("Maximum results (1-200)"),
    },
    async ({ query, platform, type, verified, kind, limit }) => {
      if (!isDatasetLoaded()) {
        return {
          content: [{
            type: "text",
            text: "Error: ExploitDB dataset not loaded. The dataset needs to be loaded at startup.",
          }],
          isError: true,
        };
      }

      try {
        const result = searchExploitDataset({ query, platform, type, verified, kind, limit });
        return {
          content: [{ type: "text", text: formatSearchResultsMarkdown(result) }],
        };
      } catch (error: any) {
        return {
          content: [{ type: "text", text: `Error searching ExploitDB: ${error.message}` }],
          isError: true,
        };
      }
    }
  );

  // ExploitDB Get by ID Tool
  server.tool(
    "exploitdb_get",
    "Get detailed information about a specific exploit by its ExploitDB ID.",
    {
      id: z.number().int().positive().describe("ExploitDB exploit ID"),
    },
    async ({ id }) => {
      if (!isDatasetLoaded()) {
        return {
          content: [{
            type: "text",
            text: "Error: ExploitDB dataset not loaded. The dataset needs to be loaded at startup.",
          }],
          isError: true,
        };
      }

      try {
        const entry = getExploitById(id);
        if (!entry) {
          return {
            content: [{ type: "text", text: `No exploit found with ID ${id}` }],
          };
        }
        return {
          content: [{ type: "text", text: formatEntryMarkdown(entry) }],
        };
      } catch (error: any) {
        return {
          content: [{ type: "text", text: `Error retrieving exploit: ${error.message}` }],
          isError: true,
        };
      }
    }
  );

  // ExploitDB Dataset Info Tool
  server.tool(
    "exploitdb_info",
    "Get information about the loaded ExploitDB dataset.",
    {},
    async () => {
      if (!isDatasetLoaded()) {
        return {
          content: [{
            type: "text",
            text: "ExploitDB dataset is not loaded.",
          }],
        };
      }

      try {
        const meta = datasetMeta();
        return {
          content: [{
            type: "text",
            text: `### ExploitDB Dataset Info\n\n` +
              `- **Generated:** ${meta.generated_at}\n` +
              `- **Entries:** ${meta.entry_count}\n` +
              `- **Total Available:** ${meta.total_available}\n` +
              `- **Limit:** ${meta.limit}`,
          }],
        };
      } catch (error: any) {
        return {
          content: [{ type: "text", text: `Error getting dataset info: ${error.message}` }],
          isError: true,
        };
      }
    }
  );
}
